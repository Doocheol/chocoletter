# 📝TIL

<br>

## 2025.01.23 (Thu)

### ✅ Today I've done

-   React API 설정
-   React 테스트 페이지 작성(Jest 포함)
-   캡처 버튼 구현
-   전체 화면 레이아웃 다시
-   Figma 디자인 특강

<br>

### ❣️ Today I've Learned

```
오늘은 View에 집중하기보다 기능이나 프로젝트 구조설계 부분을 신경썼습니다.

1. API 설정
프로젝트의 효율적인 API 통신을 위해 Axios를 활용한 공통 API 설정을 도입했습니다.
이를 통해 API 호출 시 반복되는 설정을 줄이고, 코드의 재사용성을 높일 수 있었습니다.
특히, 인증이 필요한 요청에 대해서는 Authorization Bearer 토큰을 자동으로 포함하도록 설정하여 보안성을 강화했습니다.
공통 컴포넌트로 분리함으로써 모든 API 요청이 일관된 방식으로 처리되도록 관리할 수 있게 되었고, 이는 유지보수와 확장성 측면에서도 큰 도움이 되었습니다.

2. 테스트 페이지 및 Jest
프로젝트의 안정성과 신뢰성을 높이기 위해 Jest를 활용한 테스트 환경을 구축했습니다.
테스트 주도 개발(TDD)을 추후에 적용하여 기능 구현 전에 테스트를 먼저 작성함으로써 코드의 정확성을 검증하고,
예상치 못한 버그를 사전에 방지할 수 있을 것 같습니다. 특히, 컴포넌트 단위 테스트를 통해
각 컴포넌트가 의도한 대로 동작하는지를 확인할 수 있을 것 같고 API 호출에 대한 테스트를 통해
데이터 흐름의 일관성을 유지할 수 있었습니다. 이러한 테스트 과정은 프로젝트의 유지보수성과 확장성을 크게 향상시켰습니다.

3. 캡처 버튼 구현
사용자가 웹 애플리케이션 내에서 모바일 디바이스의 화면을 손쉽게 캡처할 수 있도록 캡처 버튼을 구현했습니다.
이를 통해 사용자는 특정 요소의 화면을 이미지 파일로 저장하거나 공유할 수 있게 되었으며,
이는 사용자 경험을 크게 향상시키는 기능입니다. 특히, 웹 환경에서 모바일 디바이스의 화면을
정확하게 캡처하기 위해 관련 라이브러리를 활용하여 구현함으로써, 다양한 디바이스에서도 일관된 캡처 기능을 제공할 수 있게 되었습니다.
이러한 기능은 디버깅이나 사용자 피드백 수집 시에도 유용하게 사용될 수 있습니다.
```

<br>
<br>

## 2025.01.22 (Wed)

### ✅ Today I've done

-   Concurrent Mode (React 18)
-   React QRCode 그리기
-   카카오톡 공유 API (JavaScript)
-   메인 화면 - 공유 기능 개발
-   Figma 디자인 특강

<br>

### ❣️ Today I've Learned

```
오늘은 메인 화면의 공유 기능을 개발하면서 여러 가지 중요한 개념과 기술을 배웠다. 특히 Concurrent Mode에 대한 이해가 가장 큰 수확이었다. 오늘 학습한 내용은 다음과 같다.

1. React QRCode 그리기

React를 활용하여 QR 코드를 생성하고 화면에 표시하는 방법을 학습했다. qrcode.react와 같은 라이브러리를 사용하여 간단하게 QR 코드를 렌더링할 수 있었고, 사용자에게 필요한 정보를 시각적으로 제공하는 데 유용하게 적용할 수 있었다.

2. 카카오톡 공유 API (JavaScript)

카카오톡의 공유 API를 JavaScript로 통합하는 방법을 배웠다. 카카오 개발자 문서를 참고하여 API 키를 설정하고, 사용자들이 버튼 클릭 시 간편하게 콘텐츠를 카카오톡으로 공유할 수 있도록 구현했다. 이를 통해 사용자 경험을 크게 향상시킬 수 있었다.

3. Concurrent Mode (React 18)

React 18에서 도입된 Concurrent Mode에 대해 깊이 있게 공부했다. Concurrent Mode를 사용하면 애플리케이션의 반응성을 높이고, 복잡한 UI 업데이트도 부드럽게 처리할 수 있다는 점을 깨달았다. 실제로 메인 화면 공유 기능을 개발하면서 Concurrent Mode의 장점을 실감할 수 있었고, 향후 프로젝트에서도 적극적으로 활용할 계획이다.

오늘 배운 내용을 바탕으로 앞으로 더 효율적이고 사용자 친화적인 기능을 개발할 수 있을 것 같아 뿌듯하다. 내일도 새로운 기술들을 계속해서 습득하고 싶다!
```

<br>
<br>

## 2025.01.21 (Tue)

### ✅ Today I've done

-   React에서 컴포넌트 마운트/언마운트 시 이벤트 리스너 관리
-   온보딩 뷰
-   공유 기능 모달
-   Figma 디자인 특강

<br>

### ❣️ Today I've Learned

```
오늘은 개발 위주로 진행하였고, 저녁엔 특강이 있어 간단하게 공부한 자료를 정리했습니다.
React에서 컴포넌트 생애주기에 따라서 이벤트 리스너 관리하는 부분에 대해서 컨설턴트님께서 말씀을 주셨습니다.

그래서 정확히 왜 필요할까? 부터 짚어 넘어갈 수 있는 시간을 가져보기로 결심했습니다.

우선, 결론부터 확인하면 메모리 누수 방지 및 성능 최적화를 위해 중요한 것으로 파악했습니다.

1. 메모리 누수 방지
- 컴포넌트가 언마운트되었는데도 이벤트 리스너가 남아 있으면, 리스너가 계속 메모리를 점유하게 된다.
이는 애플리케이션이 점점 더 많은 메모리를 사용하게 되어 성능 저하를 초래함.

2. 불필요한 함수 호출 방지
- 리스너가 제거되지 않으면, 이벤트가 발생할 때 언마운트된 컴포넌트의 핸들러 함수가 호출됨.
이는 의도하지 않은 동작이나 오류를 발생시킬 수 있음.

3. 성능 최적화
- 컴포넌트마다 독립적으로 이벤트 리스너를 추가하고 제거하면 필요한 리소스를 최소화하여
애플리케이션의 성능을 유지할 수 있음.

!!! 이벤트 리스너를 제거하기 위해서는 React의 useEffect 훅에서 클린업 함수를 반환하여 수행하면 됨!

예제 코드는 아래와 같다.
  useEffect(() => {
    // 마운트 시 이벤트 리스너 추가
    window.addEventListener('scroll', handleScroll);

    // 언마운트 시 이벤트 리스너 제거
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }, []); // 빈 배열로 의존성을 설정하여 마운트/언마운트 시에만 실행


이제는 백엔드를 넘어서 프론트에서도 더욱 메모리 및 성능을 고려할 수 있는 개발자가 되어보도록 하자!
```

<br>
<br>

## 2025.01.20 (Mon)

### ✅ Today I've done

-   전역 상태 관리 & 상태 관리 라이브러리
-   로그인, 온보딩 뷰 개발
-   React 18 프로젝트 생성 및 설정(CSR, SSR, SSG 비교 / SEO를 위한 선택)
-   SWC와 Bable : 컴파일러에 대하여

<br>

### ❣️ Today I've Learned

```
상태란 무엇일까? 리액트 애플리케이션에서의 상태는 렌더링에 영향을 줄 수 있는 동적인 데이터 값을 말한다.
- 렌더링 결과에 영향을 주는 정보를 담은 순수 자바스크립트 객체

리액트에서의 상태는 시간이 지나면서 변할 수 있는 동적인 데이터이며, 값이 변경될 때마다 컴포넌트의 렌더링 결과물에 영향을 준다. 리액트 앱 내의 상태는 지역 상태, 전역 상태, 서버 상태로 분류할 수 있다. 리액트 내부 API만을 사용하여 상태를 관리할 수 있지만 성능 문제와 상태의 복잡성으로 인해
Redux, MobX, Recoil 같은 외부 상태 관리 라이브러리를 주로 활용한다.

1. 지역 상태(Local State)
: 지역 상태는 컴포넌트 내부에서 사용되는 상태로 예를 들어 체크박스의 체크 여부나 폼의 입력값 등이 해당한다. 주로 useState 훅을 가장 많이 사용하며 때에 따라 useReducer와 같은 훅을 사용하기도 한다.

2. 전역 상태(Global State)
: 전역 상태는 앱 전체에서 공유하는 상태를 의미한다. 여러 개의 컴포넌트가 전역 상태를 사용할 수 있으며 상태가 변경되면 컴포넌트들도 업데이트된다 .또한 Prop drilling 문제를 피하고자 지역 상태를 해당 컴포넌트들 사이의 전역 상태로 공유할 수도 있다.

3. 서버 상태(Server STate)
: 서버 상태는 사용자 정보, 글 목록 등 외부 서버에 저장해야 하는 상태들을 의미한다. UI 상태와 결합하여 관리하게 되며 로딩 여부나 에러 상태 등을
포함한다. 서버 상태는 지역 상태 훅은 전역 상태와 동일한 방법으로 관리되며 최근에는 react-query, SWR같은 외부 라이브러리를 사용하여 관리하기도 한다.

[SWC와 Bable]
Babel
Babel 은 자바스크립트의 컴파일러입니다. 하는 역할로는 최신 Ecama Script 문법을 구형 버전으로 바꿔주는 역할을 하고 최적화 또한 해줍니다. 자바스크립트는 문제가 많은 언어입니다. 만든 기간은 2주일도 안되어서 세상에 급하게 나왔습니다. 때문에 버그들도 많고 개선해야 할 것들이 많습니다. 때문에 기술의 변화가 굉장히 빠르기 때문에 최신 브라우저조차 지원하지 못하는 문법과 기술들이 출현하고 있습니다.

이러한 상황으로인해 웹 개발자라면 옛날 브라우저를 사용하는 사용자들도 고려를 해야합니다. 이때 바벨은 새로운 문법이나 타입스크립트 혹은 JSX같이 다른 언어들에 대해서도 Ecma Script로 동작할 수 있도록 하위버전의 자바스크립트로 변환을 해줍니다.

바벨의 동작은 다음과 같습니다.

파싱 (parsing) : 코드를 읽고 추상 구문 트리(AST)로 변환하는 단계
출력 (printing) : 변경된 결과물을 출력하는 단계
파싱과정을 통해 고수준의 인간의 언어에서 저수준의 기계어로 변환을 합니다. 바벨은 자바스크립트 코드를 받아 AST를 만듭니다. 그리고 이것을 활용하여 새로운 자바스크립트 코드를 출력합니다.

SWC (Speedy Web Compiler)
SWC 는 자바스크립트 프로젝트의 컴파일과 번들링 모두에 사용할 수 있는, Rust라는 언어로 제작된 빌드 툴입니다. SWC는 Speedy Web Compoiler의 약자로, 말 그대로 매우 빠른 웹 컴파일러의 기능을 제공하는 툴입니다.

하지만 실제로는 컴파일의 기능만을 제공하는 것은 아닙니다. 웹팩과 같이 자바스크립트의 기능도 제공하려고 개발을 하고 있습니다. 얼마든지 기능 확장이 가능하도록 설계되어 있기 때문에, 단순한 컴파일러가 아닌 하나의 플랫폼으로 보는 것이 적절할 것 같습니다.

SWC 프로젝트의 목표는 다음과 같습니다. 개발자이신 강동윤님의 말을 따르면 느린 웹 빌드 툴 전체를 러스트로 다시 구현하는 것 이기 때문에 앞으로도 SWC의 기능은 추가될 것으로 보입니다.

기존에 사용하는 자바스크립트는 이벤트 루프 기반의 싱글 스레드를 사용합니다. 하나의 일 밖에 못하는 것입니다. 하지만 SWC 언어는 Rust 프로그래밍 언어는 병렬 처리를 고려하여 설계된 언어이기 때문에 멀티 스레드를 사용이 가능합니다. 여러 일을 동시에 할 수 있습니다.

싱글 스레드, 멀티 스레드 차이때문에 속도가 빠른거다? 그뿐만이 아닙니다. 싱글 스레드 환경에서도 SWC가 바벨보다 20배가 더 빠르다는 벤치마크의 결과도 있습니다.
```

<br>
<br>

## 2025.01.19 (Sun)

### ✅ Today I've done

-   타입 좁히기 -> 타입 가드
-   Axios 활용하기
-   NextAPiHandler 활용하기
-   리액트 훅
-   온보딩 뷰 개발해보기

<br>

### ❣️ Today I've Learned

```
[타입 가드]
- 타입스크립트에서 타입 좁히기는 변수 또는 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정을 말한다.
타입 좁히기를 통해 더 정확하고 명시적인 타입 추론을 할 수 있게 되고, 복잡한 타입을 작은 범위로 축소하여 타입 안정성을 높일 수 있다.

1. 타입 가드에 따라 분기 처리하기
타입 스크립트에서의 분기 처리는 조건문가 타입 가드를 활용하여 변수나 표현식의 타입 범위를 좁혀 다양한 상황에 따라 다른 동작을 수행하는 것을 말함.
타입 가드는 런타임에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 기능을 말한다.

[Axios 활용하기]
- fetch는 내장 라이브러리이기 때문에 따로 임포트하거나 설치할 필요 없이 사용할 수 있다.
그러나 많은 기능을 사용하려면 직접 구현해서 사용해야 한다. 이러한 번거로움 떄문에 Fetch 함수를 직접 쓰는 대신 Axios 라이브러리를 사용하고 있다.

각 서버(주문을 처리하는 서버와 장바구니를 처리하는 서버)가 담당하는 부분이 다르거나 새로운 프로젝트의 일부로 포함될 때 기존에 사용하는 API Entry(Base URL)와는
다른 새로운 URL로 요청해야 하는 상황이 생길 수 있음.

이렇게 API Entry가 2개 이상일 경우에는 각 서버의 기본 URL을 호출하도록 2개 이상의 API 요청을 처리하는 인스턴스를 따로 구성해야 한다.
이후 다른 URL로 서비스 코드를 호출할 때는 각각의 requester를 사용하면 된다.

[NextApiHandle 활용하기]
- 프로젝트에서 Next.js를 사용하고 있다면 NextApiHandler를 활용할 수 있다. NExtApiHandler는 하나의 파일 안에 하나의 핸들러를
디폴트 익스포트로 구현해야 하며 파일의 경로가 요청 경로가 된다.
핸들러를 정의하는 것은 간단하다. 응답하고자 하는 값을 정의하고 핸들러 안에서 요청에 대한 응답을 정의한다. 핸들러를 사용하는 경우
단순히 파일을 불러오는 것과 다르게 중간 과정에 응답 처리 로직을 추가할 수 있다.

[리액트 훅]
- 리액트에 훅이 추가되기 이전에는 클래스 컴포넌트에서만 상태를 가질 수 있었다. 클래스 컴포넌트에서는 componentDidMount, componentDidUpdate와 같이
하나의 생명주기 함수에서만 상태 업데이트에 따른 로직을 실행시킬 수 있었음. 간단한 형태의 컴포넌트에서는 문제가 되지 않았지만, 프로젝트 규모가
커지면서 상태를 스토어에 연결하거나 비슷한 로직을 가진 상태 업데이트 및 사이드 이펙트 처리가 불편해졌다. 또한 모든 사앹르 랗나의 함수 내에서 처리하다 보니 관심사가 뒤섞이게 되었고 상태에 따른 테스트나 잘못 발생한 사이드 이펙트의 디버깅이 어려워졌다.

1. useState
리액트 함수 컴포넌트에서 상태를 관리하기 위해 useState 훅을 활용할 수 있다.


```

<br>
<br>

## 2025.01.18 (Sat)

### ✅ Today I've done

-   타입스크립트
-   로그인 페이지(우리 서비스의 index view) 개발

<br>

### ❣️ Today I've Learned

```
TypeScript는 마이크로소프트가 공개한 자바스크립트의 슈퍼셋 언어.
Dart(구글이 자바스크립트를 대체하기 위해 제시한 새로운 언어)와 달리 자바스크립트 코드를 그대로 사용할 수 있었고, 아래와 같은 단점을 극복할 수 있었기 때문에 많은 환영을 받았다.

*슈퍼셋(Superset) : 기존 언어에 새로운 기능과 문법을 추가해서 보완하거나 향상하는 것을 말한다. 슈퍼셋 언어는 기존 언어와 호환되며 일반적으로 컴파일러 등으로 기존 언어 코드로 변환되어 실행됨.

1) 안정성 보장
- 타입스크립트는 정적 타이핑을 제공. 컴파일 단계에서 타입 검사를 해주기 때문에 자바스크립트를 사용했을 때 빈번하게 발생하는
타입 에러를 줄일 수 있고, 런타임 에러를 사전에 방지할 수 있어 안정성이 크게 높아짐.

2) 개발 생산성 향상
- VSCode 등의 IDE(VSCode는 엄밀히 텍스트 에디터이긴 하지만..) 타입 자동 완성 기능을 제공함. 이 기능으로 변수와 함수 타입을
추론할 수 있고, 리액트를 사용할 때 어떤 prop을 넘겨야 하는지 매번 확인하지 않아도 사용부에서 바로 볼 수 있기 때문에 개발 생산성이
크게 향상됨

3) 협업에 유리
- 타입스크립트를 사용하면 복잡한 애플리케이션 개발/협업에 유리. 타입스크립트는 인터페이스, 제네릭 등을 지원하는데 인터페이스가
기술되면 코드를 더 쉽게 이해할 수 있게 도와줌. 또한 복잡한 애플리케이션일수록 협업하는 개발자 수도 증가하는데 자동 완성 기능이나
기술된 인터페이스로 코드를 쉽게 파악할 수 있음.

*타입스크립트 인터페이스 : 객체 구조를 정의하는 역할. 다시 말해 특정 객체가 가져야 하는 속성과 메서드의 집합을 인터페이스로 정의해서
객체가 그 구조를 따르게 함.

4) 자바스크립트에 점진적으로 적용 가능
- 타입스크립트는 자바스크립트의 슈퍼셋이기 때문에 일괄 전환이 아닌 점진적 도입이 가능하다. 전체 프로젝트가 아닌 일부 프로젝트,
그중에서도 일부 기능부터 점진적으로 도입해볼 수 있음. 우아한형제들도 주문 접수 앱 웹 뷰의 새 긴으에 리액트와 타입스크립트를
선제적으로 적용해본 후에 대대적으로 리액트 + 타입스크립트로 개편하는 전략을 사용했다.
```

<br>
<br>

## 2025.01.17 (Fri)

### ✅ Today I've done

-   UI/UX 디자인 회의
-   **React** 프로젝트 생성 및 환경설정
-   **왜 React를 써야만 하는가?** 근거 수집/분석
-   로그인 페이지 구현 방식 공부
-   온보딩 뷰 UI/UX 고민

<br>

### ❣️ Today I've Learned

```
오늘은 1가지 큰 주제에 대해서 고민하고 배운 순간이었다.
왜 React를 써야 하는가로 시작하여, 왜 Next.js의 OOO을 써야 하는지를
하루종일 고민하고 근거를 수집하고 분석하였다.

우선 아래와 같이 선택의 근거를 정리하기로 하였다.
- 바닐라의 형태로 html, css, Javascript로만 쓸 필요는 없는가?
- 그러면 왜 React로 하는 게 나을까? Frontend의 다른 라이브러리/프레임워크는 선택지가 아닌가?
- React를 사용한다고 하면, Next.js를 선택하게 되면, 어떤 점이 좋을까?
- Next.js가 현재 어떤 버전까지 나왔으며, 무슨 버전을 선택하는 것이 우리의 개발에 유리할까?
- App router 기반으로 해야 할까? Pages router 기반으로 해야 할까?
- 하드웨어 리소스랑 서버는 불변의 상황이라고 가정할 때, 프론트에서 성능을 개선할 방법이 있을까?
- 프론트에서 성능을 개선한다면 App router는 효과적일까?
- Next.js는 기본적으로 Webpack이라는 Build tool(Bundler)을 지원하고 있지만 다른 선택지는 어떨까?

위와 같은 질문에 대한 답변을 찾아가며 오늘 하루 공부한 내용을 정리할 수 있었다.
그 중에서 Next.js 13 버전을 선택하고 알게 된 점이 있었는데 15 버전이 출시되면서 13에서 발견된 3가지의 큰 보안 취약점이 있었는데 그 부분을 GPT를 통해 정리하면서 TIL을 마무리하겠다!

1. Next.js Server-Side Request Forgery (SSRF) in Server Actions
- 서버 액션(서버 컴포넌트 및 API 라우트 등)에서 외부로 HTTP 요청을 보낼 때, 공격자가 의도치 않은 서버 내부 자원에 접근하게 만들 수 있는 취약점입니다.
- SSRF는 서버가 내부망이나 다른 서버로 임의의 요청을 보내도록 유도할 수 있어서, 심각한 보안 문제로 이어질 수 있습니다.

2. Denial of Service (DoS) in Next.js image optimization
- Next.js에서 제공하는 이미지 최적화 기능(`next/image`)을 악의적으로 이용해, 서버 리소스를 과도하게 점유할 수 있는 문제가 보고되었습니다.
- 결과적으로 서버가 정상적인 사용자 요청에 응답하지 못하게 되는, 서비스 거부(DoS) 상태가 초래될 수 있습니다.

3. Next.js authorization bypass vulnerability
- Next.js 애플리케이션에서 권한 검증이 의도대로 동작하지 않아, 공격자가 인증 없이 특정 페이지나 API에 접근할 수 있는 위험이 존재합니다.
- 이는 사용자 정보 노출, 무단 조작 등의 심각한 보안 사고로 이어질 수 있습니다.
```

<br>
<br>

## 2025.01.16 (Thu)

### ✅ Today I've Done

-   기획 일부 수정
-   **와이어 프레임** 수정
-   **React** 프로젝트 구조 설계
-   FE 역할 분담
-   Jira **백로그** 작성
-   **[SSAFY]** Figma 디자인 특강
-   **React** 공부

<br>
 
### ❣️ Today I've Learned
```
기획적으로 부족한 부분이 계속 생겨 오늘도 기획을 수정하였다.

이에 따라, 화면 설계/레이아웃 배치를 새로 하였다.

화면 설계/레이아웃 배치를 수정하는 과정에서 유저 서비스 플로우 관점에서 부족한 부분이 다시 노출되었고, 특히 WebRTC를 사용한 1-on-1 Video Calling 서비스에서 서로의 시간을 Fix하는 부분에서 결함이 있었다.

해당 결함은 Gift Receiver의 경우, Video Calling Time이 Fix되지만 Sender의 경우 시간이 확정되지 않는 문제가 발생할 수도 있었다.

FE에서 프로젝트 구조 설계가 끝났다. 그래서 비슷한 역할을 할 수 있는 카테고리를 다음과 같이 6개의 대분류로 정리하였다.

-   메인, 로그인/튜토리얼, 편지, 선물/선물함, 채팅, Video calling

상기와 같은 대분류에서 작업량을 러프하게 의논하여 보고, View 페이지를 기준으로 역할을 분담하였다. 결과적으로 Jira에는 Component 단위로 백로그를 작성할 수 있었다.

또한, 전국 단위에서 Jira 프로젝트 현황을 확인할 수 있었는데 서울 6반 3팀(A603)인 우리가 Jira 이슈의 개수가 201개로 1등을 차지하고 있었던 점이 인상 깊었다. 아무래도 프로젝트를 성공적으로 마무리 할 수 있다라는 전조 현상이 아닐까 싶다. 협업 툴을 효과적이고 효율적으로 쓸 수 있는 방향으로 지속적인 고민을 해야 할 것 같다.

오늘 Figma 디자인 특강에서는 프로토타입을 중점적으로 배울 수 있었고, IT 서비스 회사의 Design System을 사용할 수 있는 Resources에 대해서 파악할 수 있었다.

```

<br>
<br>

## 2025.01.15 (Wed)

### ✅ Today I've Done
- 레이아웃 완성
- **React** 프로젝트 구조 설계
- 유저 유입 유도 및 리텐션 확대 방안 고민
- 인앱 브라우저에서 외부 브라우저로 강제 전환 방법 공부
- 웹 서비스에서 모바일 디바이스 접근하여 카메라 촬영 구현 공부
- **[SSAFY]** Figma 디자인 특강
- **React** 공부

<br>


### ❣️ Today I've Learned
```

오늘은 완성된 화면 설계를 바탕으로 레이아웃을 최대한 Fix하기로 하였고, 우선 레이아웃까지도 마무리되었다.

그렇게 React 프로젝트 구조 설계를 시작할 수 있었다.
어제 오프닝을 하고 시작하였지만 바뀌는 부분이 존재하여 다시 pages, components를 살펴보기로 하였다.
프로젝트 구조 설계를 내일까지는 끝내야 역할 분담, Jira 백로그 작성이 가능하다고 판단하였고, 우리의 프로젝트 작업량을 빠르게 그려볼 수 있다고 생각했다. (우리는 빠른 개발이 중요한 프로젝트라는 점이 핵심이다...)

이후에는 유저 유입 유도 및 리텐션 확대 방안을 고민해보았다.

새로 유입되는 사용자들에게 서비스를 더 잘 소개하고, 어떻게 하면 지속적으로 서비스를 이용하게 할 수 있을까?
링크 공유, 온보딩, 재화 획득 방식을 제공하는 방식을 토대로 극복해보자고 결정하였다.

다음으로는 링크 공유 시 발생하는 인앱 브라우저에서 확인하는 사용자들에 대해서 외부 브라우저인 우리 서비스로 강제 전환 방법이 필요하였다.

이 부분에 대해서는 스키마(URI Scheme)나 Intent 기능을 사용하면, 버튼 클릭 시 외부 브라우저로 전환할 수 있다.
구현 시 OS별 (iOS/Android) 호환성을 고려해야 하고, 사용자가 설치한 브라우저 중 어떤 브라우저로 열지 선택하도록 처리할 수도 있다.

최근에 정리한 자료이기도 하지만 웹 서비스에서 모바일 디바이스 접근하여 카메라 촬영 구현하는 방식에 대해서 MDN 공식 문서를 조금 더 찾아보았다. 거기서 Media Capture and Streams API (Media Stream)가 어떻게 구성되고 있는지 살펴볼 수 있었다.

아울러, 권한 관리가 중요한데, 모바일 디바이스마다 권한 요청 UX/UI가 다르고, 브라우저에서 HTTPS 환경이 필수일 수 있다.
사용자 경험을 최대화하기 위해, 카메라를 직접 열어서 사진을 촬영할지, 앨범에서 이미지를 가져올지 선택할 수 있도록 설계하는 것은 아직 고민 중에 있고, Capture를 통해 네이티브 앱인 카메라로 촬영한 것처럼 구현하는 것도 같은 고민 안에 있다.

오늘 Figma 특강에서는 왜 Figma를 쓰는 것이 편한지 파악할 수 있는 시간이었고, 각 요소별 소개가 포함되었다.

```

<br>
<br>

## 2025.01.14 (Tue)

### ✅ Today I've Done
- 기획 일부 수정
- 요구사항 수집/분석
- **와이어프레임** 작성
- 카카오톡 알림 API 공부
- 미팅 w/ 컨설턴트님, 실습코치님
- Backend 챌린지 고민
- **[SSAFY]** Figma 디자인 특강
- **React** 공부

<br>


### ❣️ Today I've Learned

```

지속적으로 기획이 수정되고 있으며, 이에 따라 추가적인 요구사항을 수집하고 분석하는 과정이 진행되고 있습니다.
Frontend에서는 A/B Testing을 통해 어떤 방식이 더욱 Fit할지 고민하고 있습니다.

그리고 오늘은 컨설턴트님과 실습코치님과 함꼐 미팅이 있었습니다. 이때, Backend가 프로젝트 진행하는 기간 동안 볼륨이 작아보일 수도 있다는 우려에 대해서 얘기가 나왔고 고민해보는 시간을 가질수 있었습니다.

Backend 챌린지는 다양한 방식으로 접근할 수 있다고 생각했습니다. 볼륨이 작더라도, 내가 어느 정도 Depth까지 연구를 해봤는가? 이미 만들어진 API가 아닌 내가 기술을 직접 찾아보고 기술을 구현할 수도 있을까? 시도를 해봤나? 등에 대한 생각이 들었습니다. 그렇지만, 짧은 프로젝트 기간 동안 Depth를 파고드는 것도 중요하지만, 확장성도 충분히 고려해보았을 때, 새로운 기술을 사용하는 시간에 대해서도 긍정적으로 접근해볼 수 있다고 배울 수 있었던 시간이었습니다.

오늘부터는 Figma 디자인 특강이 시작됐습니다. 오늘은 교육용 계정을 받아 Unlimited project 생성, Dev mode 사용 가능이 가능해졌고, 이를 토대로 간단히 Figma는 어떻게 구성되고 기능을 어떻게 활용할 수 있는지 튜토리얼 시간을 가졌습니다. Figma를 시작할 때는 당장에는 공부할 생각을 크게 하지 못했는데 시작부터 다시 공부를 하는 부분에 있어서 내가 놓쳤던 부분을 생각해볼 수 있었던 강의였습니다. 가장 인상 깊었던 부분은 Figma AI이며, Figma AI를 사용하게 되면 Frontend는 사라질까? 라고 먼저 생각이 들겠지만 저는 Frontend에서 개발 속도를 단축하면 어떤 부분을 더 Depth를 가지고 파고들 수 있을까? 같은 시간 대비 퀄리티는 더욱 좋아지겠구나 라는 생각이 먼저 들었던 시간이었습니다.

끝으로 카카오톡 알림 API에 대해서 공부한 내용을 아래와 같이 정리해보았다.

1. 비즈니스 채널 연동

카카오 비즈니스 채널과 연동하기 위해서는 먼저 채널 개설 및 앱 연결이 필수다.
카카오 디벨로퍼스 사이트에서 앱을 등록한 뒤, 해당 앱을 채널과 연결해야 원하는 서비스에서 메시지를 보낼 수 있다.

2. 메시지 템플릿 설정

카카오 알림톡은 ‘비즈 메시지’로 취급되어, 특정 템플릿 검수가 필요하다.
메시지 내용이나 버튼 등을 미리 템플릿으로 등록해두고, 승인된 템플릿을 이용해야만 발송 가능하다.

3. 인증 토큰 발급

API를 통해 메시지를 전송하기 위해서는 액세스 토큰이 필요하다.
발급받은 REST API Key와 Redirect URI 등을 활용해 OAuth2 인증 과정을 거쳐 토큰을 가져온 뒤, 이를 통해 메시지 전송 요청을 한다.

4. 알림 메시지 전송 프로세스

사용자 정보(전화번호, 수신 동의 상태 등)를 확인하고, 인증에 사용될 토큰을 적용해, 실제 메시지 전송 API를 호출하여 알림톡을 발송한다.

5. 주의할 점

알림톡은 광고성 메시지 여부 등에 따라 규정이 까다로울 수 있으므로, 사전에 가이드라인을 숙지해야 한다.
템플릿 검수에 통과해야만 실제 서비스 환경에서 발송할 수 있으므로, 준비 단계에서 메시지 문구를 꼼꼼히 검토하는 것이 중요하다.

```

<br>
<br>

## 2025.01.13 (Mon)

### ✅ Today I've Done
- 기획/아이디어 회의
- 요구사항 수집/분석
- **와이어프레임** 작성
- **디자인 UI/UX** 공부
- **React** 공부

<br>


### ❣️ Today I've Learned

```

원래는 이번 주부터 아이디어 회의를 포함한 기획 주간이지만, 지난주에 아이디어는 결정되어 있었다.

그래서 기획을 잠정적으로 확정하고, 지난주 주중/주말을 이용하여 러프하게 화면 설계를 했었던 와이어프레임을 추가적으로 보완하기 시작했다.

와이어프레임 내에서 레이아웃은 우선순위를 뒤로 미뤄서 배치하기로 하고, 화면 설계를 최대한 확정지을 수 있도록 목표를 설정하여 작업하였다.

이 과정에서 Figma를 어떻게 하면 효과적으로 쓸 수 있을까? 하는 고민이 많았던 것 같다. 미리 추가로 얘기하자면 Frontend 관점에서 어떤 기능들이 필요할지 세부적으로 파악하는 계기가 되었다.

그럼 무엇을 Figma로 배웠는지 아래와 같이 정리해보았다.

-   Plugins 활용
-   UI Kit 활용
-   Section/Frame의 구분
-   Auto layout
-   Dev mode

그리고 우리 "초코레터(Chocoletter)" 서비스에서 유저들을 유입시킬 수 있는 핵심 포인트 및 유저 리텐션을 늘릴 수 있는 포인트가 UI/UX 디자인 비중이 상당히 높게 평가될 것 같다.

그래서 디자인 비중이 높아지게 되면 왜 디자인이 예뻐야 사용자가 유입된다고 생각하는지를 고려하면서 UI 기본 용어부터 공부하였다.

```

```
