# 📝TIL(Today I Learned)

---

## 2025.02.07 (금)

### ✅ 오늘 한 일

-   [FIX] QA 수정

### ❣️ 오늘 배운 점

### | withCredentials

<details>
<summary> 🤩 자세히 보기 !</summary>

`withCredentials: true`는 **JavaScript에서 `XMLHttpRequest` 또는 `fetch API`를 사용할 때, 쿠키(Cookie), HTTP 인증(Authorization) 및 SSL 클라이언트 인증서(Client Certificate)를 포함하여 요청을 보낼 수 있도록 설정하는 옵션**

---

### 1. **`withCredentials: true`의 역할**

-   브라우저의 기본 정책에서는 **Cross-Origin Request (CORS) 환경에서 자격 증명(쿠키, HTTP 인증 정보 등)이 포함되지 않도록 차단함**. 하지만, `withCredentials: true`를 설정하면 **다음과 같은 요청에서도 자격 증명이 포함되도록 허용**할 수 있음.

#### ✅ **1) 쿠키 포함 요청**

```javascript
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://example.com/api/data", true);
xhr.withCredentials = true; // 쿠키 및 인증 정보를 포함하여 요청 전송
xhr.send();
```

이렇게 하면 `example.com`이 CORS 설정에서 `Access-Control-Allow-Credentials: true`를 허용하고 있다면, 브라우저가 **쿠키를 포함한 요청을 보낼 수 있음**.

---

#### ✅ **2) `fetch API`에서 사용**

```javascript
fetch("https://example.com/api/data", {
    method: "GET",
    credentials: "include", // `withCredentials: true`와 동일한 역할
});
```

-   `credentials: "include"` → **모든 도메인에 대해 쿠키 전송 가능**
-   `credentials: "same-origin"` → **같은 출처(origin)에서만 쿠키 포함**
-   `credentials: "omit"` → **쿠키를 전송하지 않음 (기본값)**

---

### 2. **`withCredentials: true`의 동작 조건**

CORS 환경에서 `withCredentials: true`를 사용하려면, 서버에서 다음을 설정해야 함.

#### ✅ **서버 응답 헤더에서 허용해야 함**

```http
Access-Control-Allow-Origin: https://your-client.com  # `*`(와일드카드) 사용 불가능
Access-Control-Allow-Credentials: true
```

-   `Access-Control-Allow-Origin: *`과 함께 `Access-Control-Allow-Credentials: true`를 **같이 사용할 수 없음** (보안상의 이유)
-   특정 출처(`your-client.com`)를 명시적으로 허용해야 함

---

### 3. **`withCredentials: true`가 필요한 상황**

✅ **1) API 요청 시 쿠키를 포함해야 할 때**

-   로그인 유지 기능 (JWT, 세션 쿠키 사용)
-   보안이 필요한 요청 (예: 인증이 필요한 데이터 조회)

✅ **2) `Basic Authentication` 또는 `Bearer Token` 등 인증 정보를 포함할 때**

-   HTTP `Authorization` 헤더를 이용한 API 인증 요청

✅ **3) 클라이언트 인증서(Client Certificate) 필요할 때**

-   TLS(SSL) 클라이언트를 통한 인증

---

### 4. **주의사항**

-   `withCredentials: true`는 **브라우저의 보안 정책에 의해 제한될 수 있음**.
-   `Access-Control-Allow-Origin`을 `*`로 설정하면 `Access-Control-Allow-Credentials: true`를 사용할 수 없음.
-   `credentials: "include"` 설정 없이 `fetch`를 사용하면, **쿠키가 전송되지 않음**.

---

#### 🔹 **정리**

| 설정                                     | 설명                                                          |
| ---------------------------------------- | ------------------------------------------------------------- |
| `withCredentials: true`                  | `XMLHttpRequest`에서 쿠키 및 인증 정보를 포함하여 요청을 보냄 |
| `credentials: "include"`                 | `fetch`에서 동일한 역할을 수행                                |
| `Access-Control-Allow-Credentials: true` | 서버가 자격 증명을 허용하는 응답을 보냄                       |
| `Access-Control-Allow-Origin`            | 특정 출처를 명시해야 하며 `*`과 함께 사용할 수 없음           |

👉 **쿠키 기반 인증을 사용할 경우 반드시 `withCredentials: true` 또는 `credentials: "include"`를 설정해야 함!**

</details>

<br>

## 2025.02.06 (목)

#### ✅ 오늘 한 일

-   [FIX] QA 수정

#### ❣️ 오늘 배운 점

### | Promise.all([...])

<details>
<summary> 🤩 자세히 보기 !</summary>

### 🔹 `await Promise.all([...])`의 역할과 기능

`await Promise.all([...])`은 **여러 개의 `Promise`를 병렬적으로 실행하고, 모든 `Promise`가 완료될 때까지 기다린 후 결과를 반환하는 함수**입니다.

---

### ✅ **1. `Promise.all([...])`의 기본 동작**

```javascript
const promise1 = new Promise((resolve) =>
    setTimeout(() => resolve("첫 번째 완료"), 1000)
);
const promise2 = new Promise((resolve) =>
    setTimeout(() => resolve("두 번째 완료"), 2000)
);
const promise3 = new Promise((resolve) =>
    setTimeout(() => resolve("세 번째 완료"), 3000)
);

Promise.all([promise1, promise2, promise3]).then((results) => {
    console.log(results); // ["첫 번째 완료", "두 번째 완료", "세 번째 완료"]
});
```

#### 📌 **설명**

-   `promise1`, `promise2`, `promise3`가 **동시에 실행됨** (병렬 처리)
-   모든 `Promise`가 **완료될 때까지 기다렸다가** `results` 배열을 반환
-   반환값: `["첫 번째 완료", "두 번째 완료", "세 번째 완료"]`

---

### ✅ **2. `await`와 함께 사용 (`await Promise.all([...])`)**

#### 🔹 `await`을 사용하면 **동기적인 코드처럼 작동**하지만, 내부적으로는 비동기(병렬) 실행됨.

```javascript
async function fetchData() {
    const promise1 = new Promise((resolve) =>
        setTimeout(() => resolve("데이터 1"), 1000)
    );
    const promise2 = new Promise((resolve) =>
        setTimeout(() => resolve("데이터 2"), 2000)
    );

    const results = await Promise.all([promise1, promise2]);
    console.log(results); // ["데이터 1", "데이터 2"]
}

fetchData();
```

#### 📌 **설명**

-   `await`를 사용하면 `Promise.all([...])`이 완료될 때까지 기다림.
-   하지만 내부적으로는 `promise1`, `promise2`가 **동시에 실행됨** (순차 X, 병렬 O).
-   따라서 `promise1`(1초), `promise2`(2초) 걸리지만, **최종적으로 2초 후에 모든 결과를 한 번에 받음**.

⏳ **비교: `await` 없이 순차 실행하면?**

```javascript
async function fetchDataSequentially() {
    const result1 = await new Promise((resolve) =>
        setTimeout(() => resolve("데이터 1"), 1000)
    );
    const result2 = await new Promise((resolve) =>
        setTimeout(() => resolve("데이터 2"), 2000)
    );

    console.log([result1, result2]); // ["데이터 1", "데이터 2"]
}

fetchDataSequentially();
```

-   여기서는 `result1`이 끝나고 나서야 `result2`가 실행됨 → **총 3초 소요**
-   `Promise.all([...])`을 쓰면 병렬 실행돼서 2초면 끝남!

---

### ✅ **3. `Promise.all([...])`의 특징**

#### 🔹 **(1) 모든 `Promise`가 성공해야 `then` 실행**

```javascript
const p1 = Promise.resolve("성공 1");
const p2 = Promise.resolve("성공 2");
const p3 = Promise.reject("실패 3");

Promise.all([p1, p2, p3])
    .then((results) => console.log(results))
    .catch((error) => console.error("에러 발생:", error));
```

⛔ **실패하는 `Promise`가 있으면 즉시 `catch`로 이동** → 결과 출력:

```
에러 발생: 실패 3
```

-   `Promise.all([...])`은 **모든 `Promise`가 성공해야지만** `then` 실행됨.
-   하나라도 실패하면 즉시 **다른 `Promise`가 끝나지 않아도** `catch`로 이동.

---

### ✅ **4. `Promise.allSettled([...])`과 차이점**

**💡 `Promise.allSettled([...])`은 개별 `Promise`의 성공/실패 여부와 관계없이 모든 결과를 반환**.

```javascript
const p1 = Promise.resolve("성공 1");
const p2 = Promise.reject("실패 2");
const p3 = Promise.resolve("성공 3");

Promise.allSettled([p1, p2, p3]).then((results) => console.log(results));
```

📌 출력 결과:

```javascript
[
    { status: "fulfilled", value: "성공 1" },
    { status: "rejected", reason: "실패 2" },
    { status: "fulfilled", value: "성공 3" },
];
```

-   `Promise.all()`과 달리, **실패하더라도 전체 결과를 반환**.
-   개별 `Promise`의 상태를 확인할 때 유용.

---

### ✅ **5. `Promise.all([...])`의 활용 사례**

#### 1️⃣ **여러 API 요청을 동시에 보내기**

```javascript
async function fetchData() {
    const userData = fetch("https://api.example.com/user");
    const postData = fetch("https://api.example.com/posts");
    const commentData = fetch("https://api.example.com/comments");

    const [user, posts, comments] = await Promise.all([
        userData,
        postData,
        commentData,
    ]);
    console.log(await user.json(), await posts.json(), await comments.json());
}
fetchData();
```

-   **병렬 요청을 통해 API 응답 속도를 단축**.
-   `await` 없이 `fetch()` 실행 후 한꺼번에 결과를 받아서 처리.

---

#### 2️⃣ **여러 개의 비동기 함수 실행**

```javascript
async function processTasks() {
    const task1 = async () => "작업 1 완료";
    const task2 = async () => "작업 2 완료";
    const task3 = async () => "작업 3 완료";

    const results = await Promise.all([task1(), task2(), task3()]);
    console.log(results); // ["작업 1 완료", "작업 2 완료", "작업 3 완료"]
}
processTasks();
```

-   병렬 처리로 작업 시간 단축 가능!

---

### ✅ **정리**

| 메서드                      | 동작 방식                                                                      |
| --------------------------- | ------------------------------------------------------------------------------ |
| `Promise.all([...])`        | 모든 `Promise`가 완료될 때까지 기다린 후 결과 반환 (하나라도 실패하면 `catch`) |
| `await Promise.all([...])`  | 병렬 실행 후 모든 결과를 기다림 (비동기 코드 최적화)                           |
| `Promise.allSettled([...])` | 모든 `Promise`가 완료될 때까지 기다리지만, 실패해도 전체 결과 반환             |

✅ **`Promise.all([...])`을 사용하면 여러 개의 `Promise`를 병렬 실행하여 최적화 가능!**  
✅ **단, 하나라도 실패하면 전체가 실패하므로 예외 처리가 필요!**  
✅ **실패한 `Promise`도 포함한 결과를 받고 싶다면 `Promise.allSettled([...])` 사용!**

</details>

<br>

## 2025.02.05 (수)

#### ✅ 오늘 한 일

-   [FIX] QA 수정

#### ❣️ 오늘 배운 점

### | 로컬 스토리지(Local Storage), 세션 스토리지(Session Storage), 쿠키(Cookie)

<details>
<summary> 🤩 자세히 보기 !</summary>

### ✅ **로컬 스토리지(Local Storage), 세션 스토리지(Session Storage), 쿠키(Cookie) 비교 정리**

웹 브라우저에서는 데이터를 저장할 수 있는 방식으로 **로컬 스토리지(Local Storage), 세션 스토리지(Session Storage), 쿠키(Cookie)** 가 사용됩니다. 각각의 차이점과 특징을 정리하면 다음과 같습니다.

---

### 📌 **1. 로컬 스토리지(Local Storage)**

#### 📍 **특징**

-   **데이터가 브라우저에 영구적으로 저장됨 (삭제하지 않는 한 유지)**
-   **브라우저가 종료되어도 데이터가 유지됨**
-   5MB ~ 10MB 정도의 저장 용량을 제공 (브라우저마다 다름)
-   서버로 자동 전송되지 않음 → **보안성이 높음**

#### 📍 **사용 예시**

```javascript
// 데이터 저장
localStorage.setItem("username", "Alice");

// 데이터 불러오기
const user = localStorage.getItem("username");
console.log(user); // "Alice"

// 데이터 삭제
localStorage.removeItem("username");

// 전체 데이터 삭제
localStorage.clear();
```

#### 📍 **사용 사례**

✅ 로그인 유지 (토큰 저장)  
✅ 사용자 설정 저장 (다크 모드, 언어 설정 등)  
✅ 캐싱 데이터 저장

---

### 📌 **2. 세션 스토리지(Session Storage)**

#### 📍 **특징**

-   **브라우저 탭(세션)이 닫히면 데이터가 삭제됨**
-   다른 탭에서는 세션 스토리지에 접근할 수 없음 → **탭 단위로 데이터가 관리됨**
-   저장 용량은 **로컬 스토리지와 동일 (5MB ~ 10MB 정도)**
-   서버로 자동 전송되지 않음 → **보안성이 높음**

#### 📍 **사용 예시**

```javascript
// 데이터 저장
sessionStorage.setItem("sessionID", "123456");

// 데이터 불러오기
const sessionId = sessionStorage.getItem("sessionID");
console.log(sessionId); // "123456"

// 데이터 삭제
sessionStorage.removeItem("sessionID");

// 전체 데이터 삭제
sessionStorage.clear();
```

#### 📍 **사용 사례**

✅ **사용자가 브라우저를 닫을 때까지 유지해야 하는 데이터**  
✅ **쇼핑몰에서 페이지를 이동할 때 임시로 장바구니 데이터 저장**  
✅ **폼 입력 데이터 임시 저장 (페이지 새로고침해도 유지되도록)**

---

### 📌 **3. 쿠키(Cookie)**

#### 📍 **특징**

-   **브라우저 종료 후에도 유지 가능 (만료일 지정 가능)**
-   **서버로 자동 전송됨 → HTTP 요청마다 포함되어 보안에 주의해야 함**
-   크기가 **4KB로 제한됨**
-   만료 기간을 지정하지 않으면 **세션 쿠키(브라우저 종료 시 삭제)** 로 동작함
-   보안 취약점 (XSS, CSRF 공격)에 노출될 가능성이 있음

#### 📍 **사용 예시**

```javascript
// 쿠키 저장 (유효기간 7일 설정)
document.cookie =
    "username=Alice; expires=" + new Date(2025, 0, 1).toUTCString();

// 쿠키 읽기
console.log(document.cookie); // "username=Alice"

// 쿠키 삭제 (만료 날짜를 과거로 설정)
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC;";
```

#### 📍 **사용 사례**

✅ **사용자 인증 (세션 관리, 로그인 유지)**  
✅ **광고 및 트래킹 (방문자 추적, 개인화된 광고 제공)**  
✅ **사용자 환경 설정 저장 (최근 본 상품, 언어 설정 등)**

---

### 📌 **4. 로컬 스토리지, 세션 스토리지, 쿠키 비교표**

| 비교 항목                      | 로컬 스토리지 (Local Storage) | 세션 스토리지 (Session Storage)   | 쿠키 (Cookie)                                   |
| ------------------------------ | ----------------------------- | --------------------------------- | ----------------------------------------------- |
| **데이터 유지 기간**           | 영구적 (삭제 전까지 유지)     | 브라우저 탭 닫으면 삭제           | 만료일 설정 가능 (기본적으로 세션 종료 시 삭제) |
| **브라우저 종료 후 유지 여부** | ✅ 유지됨                     | ❌ 유지되지 않음                  | ✅ 유지 가능 (만료일 설정 필요)                 |
| **서버로 자동 전송**           | ❌ 전송되지 않음              | ❌ 전송되지 않음                  | ✅ 요청마다 자동 전송됨                         |
| **저장 용량**                  | 5MB ~ 10MB                    | 5MB ~ 10MB                        | 4KB 제한                                        |
| **보안성**                     | 상대적으로 안전               | 상대적으로 안전                   | 보안 취약 (XSS, CSRF 위험)                      |
| **주요 사용 사례**             | 설정 저장, 캐싱, 장기 데이터  | 임시 데이터 (폼 데이터, 장바구니) | 로그인 유지, 트래킹, 사용자 인증                |

---

## ✅ **최적의 선택은?**

-   **인증 정보 (토큰 등)** → **로컬 스토리지 또는 세션 스토리지** (쿠키는 보안 위험 있음)
-   **임시 데이터 (세션 유지 정보)** → **세션 스토리지**
-   **장기적인 사용자 설정 저장** → **로컬 스토리지**
-   **서버에 자동으로 전송해야 할 데이터** → **쿠키**

👉 **쿠키는 서버와 함께 사용할 때 필수적이지만, 민감한 정보를 저장할 때는 보안에 주의해야 함**.  
👉 **로컬/세션 스토리지는 서버로 전송되지 않아 보안성이 높지만, CSRF 보호가 필요하면 쿠키 사용이 적절할 수 있음**.

</details>

<br>

## 2025.01.31 (금)

### ✅ 오늘 한 일

-   [FEAT] 언박싱 스케줄 조회 및 불가능한 시간 막기
-   [FIX] SelectGiftTypeView - 디자인 수정
-   [FIX] SentGiftView 디자인 수정
-   [CHORE] 디테일 수정

### ❣️ 오늘 배운 점

### | useCallback

<details>
<summary> 🤩 자세히 보기 !</summary>

### **`useCallback`의 사용 이유**

-   `useCallback`은 React의 훅(Hook) 중 하나로, **컴포넌트가 리렌더링될 때 동일한 콜백 함수를 재사용**하기 위해 사용
-   즉, **불필요한 함수 재생성을 방지하여 성능 최적화**를 수행

#### ✅ **주요 사용 목적**

1. **불필요한 렌더링 방지**
    - 함수가 불필요하게 다시 생성되는 것을 막아, 하위 컴포넌트가 불필요하게 렌더링되는 것을 방지
2. **메모이제이션을 통한 성능 최적화**
    - `useCallback`을 사용하면 함수가 캐싱되어, **의존성이 변경되지 않으면 같은 함수 객체를 재사용**
3. **함수의 참조값 유지**
    - `useEffect`의 **의존성 배열**에서 함수가 계속 변경되지 않도록 유지할 수 있음
    - `React.memo`와 함께 사용하면 **불필요한 자식 컴포넌트의 리렌더링을 방지**할 수 있음

---

### **📌 `useCallback` 사용 예제**

```jsx
import { useState, useCallback } from "react";
import ChildComponent from "./ChildComponent";

const ParentComponent = () => {
    const [count, setCount] = useState(0);

    // ✅ useCallback을 사용하여 동일한 함수 참조 유지
    const handleClick = useCallback(() => {
        console.log("Button clicked");
    }, []);

    return (
        <div>
            <h1>Count: {count}</h1>
            <button onClick={() => setCount(count + 1)}>Increase Count</button>
            <ChildComponent onClick={handleClick} />
        </div>
    );
};

export default ParentComponent;
```

```jsx
import React from "react";

const ChildComponent = React.memo(({ onClick }) => {
    console.log("ChildComponent re-rendered");
    return <button onClick={onClick}>Click me</button>;
});

export default ChildComponent;
```

#### 📌 **결과**

-   `useCallback`을 사용하지 않으면 `handleClick` 함수가 매번 새로 생성되며 `ChildComponent`가 리렌더링됨.
-   `useCallback`을 사용하면 `handleClick`이 동일한 함수 참조를 유지하여, `ChildComponent`는 `React.memo`로 인해 리렌더링되지 않음.

---

### **`useCallback`의 장단점**

#### ✅ **장점**

1. **불필요한 함수 재생성 방지**
    - 매 렌더링마다 새로운 함수 객체가 생성되는 것을 막음.
2. **자식 컴포넌트의 불필요한 리렌더링 방지**
    - `React.memo`와 함께 사용하면, props로 전달된 함수가 변하지 않아 불필요한 렌더링을 줄일 수 있음.
3. **의존성 배열을 이용한 최적화 가능**
    - 특정 상태나 props가 변경될 때만 함수가 새로 생성되도록 조절 가능.

#### ❌ **단점**

1. **불필요한 `useCallback` 사용 시 오히려 성능 저하**
    - `useCallback` 자체도 메모이제이션 비용이 발생하기 때문에, **함수를 다시 생성하는 비용보다 메모이제이션 비용이 클 경우 성능이 저하될 수 있음**.
    - 예를 들어, 한 번만 사용하는 함수라면 굳이 `useCallback`을 사용할 필요 없음.
2. **의존성 배열 관리 필요**
    - `useCallback` 내부에서 사용하는 변수를 의존성 배열에 포함해야 하므로, 관리가 어려울 수 있음.
    - 잘못된 의존성 설정은 **원하지 않는 동작**을 유발할 수 있음.

---

### **`useCallback` 사용이 적절한 경우**

-   **자식 컴포넌트가 `React.memo`를 사용하고, props로 함수를 전달할 때**
-   **렌더링 최적화가 필요한 경우 (ex. 이벤트 핸들러, API 호출 핸들러)**
-   **의존성이 자주 변경되지 않는 경우**

---

### **`useCallback`을 사용하지 않아도 되는 경우**

-   **간단한 함수** (ex. 단순한 이벤트 핸들러)
-   **컴포넌트가 자주 리렌더링되지 않는 경우**
-   **콜백을 props로 전달할 필요가 없는 경우**

---

### **결론**

-   `useCallback`은 불필요한 함수 재생성을 방지하여 성능을 최적화하는 훅이지만, **무조건 사용하는 것이 최적은 아님**.
-   **자식 컴포넌트의 불필요한 리렌더링을 막을 때 효과적**.
-   **메모이제이션 비용이 함수 재생성 비용보다 높다면 오히려 비효율적**이므로, **적절한 사용이 중요**함.

</details>

<br>

## 2025.01.26 (일)

### ✅ 오늘 한 일

-   [FEAT] LetterView - 403에러 화면 분리
-   [FEAT] ReceiveView - API 호출
-   [FEAT] WriteQuestionLetterView - ShuffleButton 작성
-   [FEAT] SetTimeView - TimeButton 작성

### ❣️ 오늘 배운 점

### | Context API와 Recoil의 차이점

<details>
<summary> 🤩 자세히 보기 !</summary>

| 구분                     | Context API                                           | Recoil                                           |
| ------------------------ | ----------------------------------------------------- | ------------------------------------------------ |
| **사용 목적**            | 글로벌 상태 관리 (주로 테마, 인증, 언어 설정 등)      | 상태 관리 라이브러리 (Redux와 유사한 역할 수행)  |
| **사용 방식**            | `React.createContext()`와 `useContext()` 사용         | `atom`, `selector`, `useRecoilState()` 등 사용   |
| **리렌더링 최적화**      | 부모-자식 관계에서 불필요한 리렌더링이 발생할 수 있음 | Recoil의 `atom` 단위 상태 관리로 리렌더링 최소화 |
| **비동기 지원**          | 자체적으로 지원하지 않음 (useEffect로 처리해야 함)    | `selector`에서 비동기 상태를 쉽게 관리 가능      |
| **Redux 대체 가능 여부** | 대체보다는 보완적인 역할                              | Redux 대체 가능 (Redux보다 사용법이 간단함)      |
| **공식 지원**            | React 기본 제공                                       | Facebook 개발, 별도 라이브러리 설치 필요         |

---

### 1. **Context API 예제**

#### 🔹 `ThemeContext` 정의

```jsx
import React, { createContext, useContext, useState } from "react";

// Context 생성
const ThemeContext = createContext();

export const ThemeProvider = ({ children }) => {
    const [theme, setTheme] = useState("light");

    const toggleTheme = () => {
        setTheme((prev) => (prev === "light" ? "dark" : "light"));
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            {children}
        </ThemeContext.Provider>
    );
};

// useTheme 커스텀 훅 생성
export const useTheme = () => useContext(ThemeContext);
```

#### 🔹 `App.js`

```jsx
import React from "react";
import { ThemeProvider, useTheme } from "./ThemeContext";

const ThemeButton = () => {
    const { theme, toggleTheme } = useTheme();
    return (
        <button
            onClick={toggleTheme}
            style={{
                background: theme === "light" ? "#fff" : "#333",
                color: theme === "light" ? "#000" : "#fff",
            }}
        >
            현재 테마: {theme} (클릭해서 변경)
        </button>
    );
};

const App = () => {
    return (
        <ThemeProvider>
            <div>
                <h1>Context API 사용 예제</h1>
                <ThemeButton />
            </div>
        </ThemeProvider>
    );
};

export default App;
```

🔹 **문제점**

-   `ThemeContext.Provider` 내부의 모든 하위 컴포넌트가 리렌더링됨.
-   규모가 커지면 성능 문제가 발생할 수 있음.

---

### 2. **Recoil 예제**

Recoil을 사용하면 **컴포넌트 간 상태 공유가 더 쉽고, 불필요한 리렌더링이 적습니다.**

#### 🔹 Recoil 상태 정의 (`themeAtom.js`)

```jsx
import { atom } from "recoil";

export const themeState = atom({
    key: "themeState",
    default: "light",
});
```

#### 🔹 `App.js`

```jsx
import React from "react";
import { RecoilRoot, useRecoilState } from "recoil";
import { themeState } from "./themeAtom";

const ThemeButton = () => {
    const [theme, setTheme] = useRecoilState(themeState);

    const toggleTheme = () => {
        setTheme((prev) => (prev === "light" ? "dark" : "light"));
    };

    return (
        <button
            onClick={toggleTheme}
            style={{
                background: theme === "light" ? "#fff" : "#333",
                color: theme === "light" ? "#000" : "#fff",
            }}
        >
            현재 테마: {theme} (클릭해서 변경)
        </button>
    );
};

const App = () => {
    return (
        <RecoilRoot>
            <div>
                <h1>Recoil 사용 예제</h1>
                <ThemeButton />
            </div>
        </RecoilRoot>
    );
};

export default App;
```

🔹 **Recoil의 장점**

-   `atom`을 사용하면 **필요한 컴포넌트만 리렌더링**됨.
-   `selector`를 활용하면 **비동기 상태도 쉽게 관리**할 수 있음.

---

### **정리**

| 비교 항목                | Context API                                   | Recoil                                 |
| ------------------------ | --------------------------------------------- | -------------------------------------- |
| **리렌더링 문제**        | 전역 상태 변경 시 모든 하위 컴포넌트 리렌더링 | `atom`을 사용해 필요한 부분만 리렌더링 |
| **비동기 데이터**        | `useEffect`와 상태 변수를 조합해야 함         | `selector`를 사용해 비동기 관리 가능   |
| **사용 방법**            | `createContext()` + `useContext()`            | `atom`, `selector`, `useRecoilState()` |
| **Redux 대체 가능 여부** | 불가능 (보완적 역할)                          | 가능 (Redux보다 가벼움)                |

-   작은 프로젝트에서는 **Context API**가 적합.
-   **Redux 대체 수준의 상태 관리**가 필요하면 **Recoil**이 적합.

</details>

<br>

## 2025.01.23 (목)

### ✅ 오늘 한 일

-   [FEAT] WriteQuestionLetterView - 초안 개발
-   [FEAT] SetTimeView - MessageSentSuccessfullyModal 작성
-   [FEAT] ReceiveView - 화상 연결 일정 정보 불러오기

### ❣️ 오늘 배운 점

### | hook 과 utils

<details>
<summary> 🤩 자세히 보기 !</summary>

### **`hook` 파일**

-   `hook` 파일은 주로 React와 같은 프레임워크에서 사용되는 커스텀 훅(Custom Hook)을 정의하는 데 사용
-   커스텀 훅은 반복되는 로직을 추출하여 재사용성을 높이고 컴포넌트를 간결하게 유지하기 위한 도구

#### 주요 특징

-   **React 환경**에서 상태 관리, API 호출, 이벤트 처리 등의 로직을 캡슐화.
-   **React 생명주기**와 관련된 로직 포함 가능 (예: `useEffect`, `useState` 활용).
-   컴포넌트의 상태와 동작을 관리하는 데 초점.

#### 예시

```javascript
// hooks/useFetchData.js
import { useState, useEffect } from "react";

export const useFetchData = (url) => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        fetch(url)
            .then((res) => res.json())
            .then((data) => {
                setData(data);
                setLoading(false);
            });
    }, [url]);

    return { data, loading };
};
```

**사용**

```javascript
import { useFetchData } from "./hooks/useFetchData";

const MyComponent = () => {
    const { data, loading } = useFetchData("/api/data");

    return loading ? <p>Loading...</p> : <div>{JSON.stringify(data)}</div>;
};
```

#### 목적

-   React 컴포넌트의 로직을 모듈화하여 재사용성을 높임.
-   상태 및 생명주기 로직을 분리해 컴포넌트의 가독성 향상.

---

### **`utils` 파일**

-   `utils` 파일은 **일반적으로 사용되는 순수 함수**나 **독립적인 유틸리티 함수**를 정의하는 데 사용
-   React와 무관하게 동작하며, 특정 데이터 처리, 형식 변환, 계산 등을 담당

#### 주요 특징

-   **프레임워크 비의존적**: React, Vue, Node.js 등 어디에서든 사용 가능.
-   상태 관리나 생명주기 로직이 필요하지 않은 순수한 작업 포함.
-   **범용적인 재사용**이 가능한 함수 모음.

#### 예시

```javascript
// utils/calculate.js
export const calculateSum = (numbers) =>
    numbers.reduce((sum, num) => sum + num, 0);
```

**사용**

```javascript
import { calculateSum } from "./utils/calculate";

const MyComponent = () => {
    const numbers = [1, 2, 3, 4];
    const sum = calculateSum(numbers);

    return <p>Sum: {sum}</p>;
};
```

#### 목적

-   데이터 처리, 형식 변환 등 반복되는 로직을 추출해 코드 중복을 방지.
-   비즈니스 로직과 관련된 핵심 기능 제공.

---

### **차이점 요약**

| **구분**      | **`hook` 파일**                                            | **`utils` 파일**                                         |
| ------------- | ---------------------------------------------------------- | -------------------------------------------------------- |
| **주요 역할** | React 컴포넌트와 관련된 상태 및 로직 처리                  | 데이터 처리, 계산 등 순수 함수 제공                      |
| **사용 환경** | React 환경 (주로 함수형 컴포넌트)                          | 프레임워크와 무관 (React, Node.js 등 어디서든 사용 가능) |
| **포함 내용** | 상태 관리, 생명주기 로직, 이벤트 핸들링 등 React 전용 로직 | 데이터 변환, 계산, 유틸리티 함수 등                      |
| **의존성**    | React 훅(`useState`, `useEffect` 등) 의존                  | 의존성 없음 (순수 함수)                                  |
| **예시**      | API 호출, 컴포넌트 상태 관리                               | 숫자 합계 계산, 날짜 포맷 변환                           |

---

### 결론

-   **React 컴포넌트 로직**을 모듈화하려면 `hook` 파일.
-   **독립적인 유틸리티 함수**를 재사용하려면 `utils` 파일.

</details>

<br>

## 2025.01.22 (수)

### ✅ 오늘 한 일

-   SelectLetterTypeView/SelectGiftTypeView/SentGiftView/WriteGeneralLetterView 뼈대 작성
-   API 관련 해서 react 코드 확인

### ❣️ 오늘 배운 점

-   관통 프로젝트에서 router를 이용한 api 호출이 react에서는 어떠한 흐름으로 변하게 되었는지 배움.

<br>

### React에서 API를 활용하기

---

<details>
<summary> 1. 폴더 구조</summary>

```
src/
├── components/       # UI 컴포넌트 폴더
│   ├── UserList.jsx
├── services/         # API 호출 관련 파일
│   ├── api.js
├── hooks/            # 커스텀 훅
│   ├── useFetchUsers.js
├── App.js            # 메인 컴포넌트
├── index.js          # 진입 파일
```

---

</details>

<details>
<summary> 2. 코드 예시 </summary>

#### **1. API 호출 함수 (services/api.js)**

```javascript
import axios from "axios";

// Axios 기본 설정
const api = axios.create({
    baseURL: "https://jsonplaceholder.typicode.com", // API의 기본 URL
    headers: {
        "Content-Type": "application/json",
    },
});

// 사용자 데이터 가져오기
export const fetchUsers = async () => {
    const response = await api.get("/users");
    return response.data;
};
```

#### **2. 커스텀 훅 (hooks/useFetchUsers.js)**

```javascript
import { useState, useEffect } from "react";
import { fetchUsers } from "../services/api";

const useFetchUsers = () => {
    const [users, setUsers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const getUsers = async () => {
            try {
                const data = await fetchUsers();
                setUsers(data);
            } catch (err) {
                setError(err.message);
            } finally {
                setLoading(false);
            }
        };

        getUsers();
    }, []);

    return { users, loading, error };
};

export default useFetchUsers;
```

#### **3. 사용자 목록 컴포넌트 (components/UserList.jsx)**

```javascript
import React from "react";
import useFetchUsers from "../hooks/useFetchUsers";

const UserList = () => {
    const { users, loading, error } = useFetchUsers();

    if (loading) return <p>Loading...</p>;
    if (error) return <p>Error: {error}</p>;

    return (
        <ul>
            {users.map((user) => (
                <li key={user.id}>
                    {user.name} ({user.email})
                </li>
            ))}
        </ul>
    );
};

export default UserList;
```

#### **4. 메인 컴포넌트 (App.js)**

```javascript
import React from "react";
import UserList from "./components/UserList";

const App = () => {
    return (
        <div>
            <h1>User List</h1>
            <UserList />
        </div>
    );
};

export default App;
```

</details>

<br>

## 2025.01.21 (화)

### ✅ 오늘 한 일

-   next에서 react로 전환하여 ReceiveView & LetterView 수정(API는 추가로 수정해야함)
-   API 관련 해서 react 코드 확인

### ❣️ 오늘 배운 점

-   React에서 API를 호출하는 방식에 대해 조금 알게되었음.
-   관통 프로젝트 때와 달리, 한 페이지에 모든 컴포넌트를 넣는 방식이 아닌 공통적으로 계속 활용되는 컴포넌트는 common 폴더에서 관리하고 활용하는 방식으로 진행하는 방법을 배움.
-   컨설턴트님의 피드백 덕분에 export default와 export의 차이를 알게 되었음. 이전처럼 막 코드를 작성하는 것이 아니라, 최대한 깔끔하고 구조화된 코드를 작성하려고 노력해야겠다고 생각함.
    (물론, 마감 기한을 준수하는 것이 가장 중요!)

<br>

### | export default vs export

| **특징**          | **`export default`**                           | **`export`**                                   |
| ----------------- | ---------------------------------------------- | ---------------------------------------------- |
| **내보내기 개수** | 한 모듈에 하나만 사용 가능                     | 여러 값을 내보낼 수 있음                       |
| **가져오기 이름** | 이름을 자유롭게 지정 가능                      | 정확한 이름으로 가져와야 함                    |
| **사용 사례**     | 주요 값(기능, 클래스 등) 하나만 내보낼 때 적합 | 여러 값(유틸리티 함수, 상수 등) 내보낼 때 적합 |

---

<br>

## 2025.01.20 (월)

### ✅ 오늘 한 일

-   next에서 파라미터 전달하는 방법 이해
-   next에서 react로 전환(SSR을 사용하지 않기로 함)

### ❣️ 오늘 배운 점

-   아무 생각 없이 Next.js를 사용하기로 했지만, 오늘 우리가 정말 Next.js를 사용할 이유가 있는지 다시 고민해볼 기회를 가질 수 있어 좋았음. 특히 렌더링 방식에 대해 깊이 알지 못했는데, 이번 기회를 통해 SSR, CSR, SSG의 특징과 차이점을 배울 수 있었음.

<br>

### | React 대비 Next.js의 차이

| **기능**          | **React**                    | **Next.js**                  |
| ----------------- | ---------------------------- | ---------------------------- |
| **렌더링 방식**   | CSR(CSR 확장 가능)           | CSR, SSR, SSG, ISR 모두 지원 |
| **라우팅**        | 수동 설정(React Router 필요) | 파일 기반 라우팅             |
| **SEO**           | 기본적으로 SEO 비적합        | SSR/SSG로 SEO 최적화 가능    |
| **이미지 최적화** | 수동 처리 필요               | Next.js Image 컴포넌트 제공  |
| **백엔드 통합**   | 별도 설정 필요               | API Routes 기본 제공         |

---

<br>

### | 렌더링 방식의 차이

| 렌더링 방식 | **데이터 가져오는 위치**     | **HTML 생성 시점**          | **SEO** | **사용 사례**                   |
| ----------- | ---------------------------- | --------------------------- | ------- | ------------------------------- |
| **CSR**     | 클라이언트                   | 브라우저에서 동적으로 생성  | 불리함  | 대화형 SPA, 실시간 대시보드     |
| **SSR**     | 서버                         | 요청 시마다 생성            | 유리함  | 블로그, 전자상거래 사이트       |
| **SSG**     | 빌드 시(Build Time)          | 빌드 시 미리 생성           | 유리함  | 정적 콘텐츠 제공 웹사이트       |
| **ISR**     | 빌드 시 + 일정 주기마다 갱신 | 빌드 시 생성 후 주기적 갱신 | 유리함  | 콘텐츠가 자주 변경되는 웹사이트 |

---

<br>

## 2025.01.17 (금)

### ✅ 오늘 한 일

-   프로젝트 생성

### ❣️ 오늘 배운 점

-   프로젝트를 생성하며 버전과 기본 설정을 다시 한번 신중히 검토하는 기회를 가질 수 있었음음. 예를 들어, Next.js에서 앱 라우터(App Router)와 페이지 라우터(Page Router) 중 어떤 방식을 사용할지 고민했고, 각 방식에 따른 디렉토리 구조와 명명의 차이점을 고려하며 적합한 선택을 내리고자 함.

<br>

#### | 페이지 라우터 vs 앱 라우터 구조 비교

| **기능**               | **페이지 라우터**                            | **앱 라우터**                                   |
| ---------------------- | -------------------------------------------- | ----------------------------------------------- |
| **라우트 정의 방식**   | 파일 이름 기반 (`pages/index.js` → `/`)      | 디렉토리와 파일 역할 기반 (`app/page.js` → `/`) |
| **공통 레이아웃 관리** | `_app.js`로 전체 페이지 공통 레이아웃 관리   | `layout.js`로 경로별 공통 레이아웃 관리         |
| **동적 라우팅**        | `[id].js` 파일로 구현                        | `[id]/page.js` 디렉토리로 구현                  |
| **API 라우트 위치**    | `pages/api/` 디렉토리 (`pages/api/posts.js`) | `app/api/` 디렉토리 (`app/api/posts/route.js`)  |
| **중첩 라우팅**        | 지원하지 않음                                | `layout.js`를 사용해 중첩 라우팅 지원           |

<br>
 
### | Next.js 13 vs Next.js 14 비교

| **특징**                          | **Next.js 13**                   | **Next.js 14**                          |
| --------------------------------- | -------------------------------- | --------------------------------------- |
| **App Router**                    | 초기 도입, 사용 가능             | 기능 개선 및 안정화                     |
| **React Server Components (RSC)** | 기본 지원                        | RSC 최적화 및 사용성 개선               |
| **번들러**                        | Webpack (TurboPack은 실험적)     | TurboPack 기본 지원                     |
| **Server Actions**                | 지원되지 않음                    | 서버에서 동작하는 함수 도입             |
| **SEO 및 메타 관리**              | 기본적인 메타 관리               | Metadata API로 더 세밀한 메타 관리 가능 |
| **Open Graph 이미지**             | 정적 이미지 사용                 | 동적 Open Graph 이미지 생성 지원        |
| **빌드 속도**                     | Webpack 기반으로 상대적으로 느림 | TurboPack으로 더 빠른 빌드              |
| **ESM 지원**                      | 실험적 ESM 지원                  | ESM이 기본 설정                         |
| **CSS/JS 최적화**                 | 기본 제공                        | 더 세밀하고 빠른 최적화                 |

<br>

## 2025.01.16 (목)

### ✅ 오늘 한 일

-   프론트엔드 디렉토리 구조 확정
-   Jira 백로그 작성

### ❣️ 오늘 배운 점

-   우리 팀이 JIRA 이슈 관리에서 1위를 기록한 점이 재밌었음. 생성된 이슈들을 체계적으로 해결해 나간다면 프로젝트를 성공적으로 마무리할 수 있을 것이라는 확신이 듦. JIRA를 활용할 기회가 흔치 않은 만큼, 이번 기회를 통해 효과적으로 사용법을 익히고 협업 능력을 더욱 강화할 수 있기를 기대함.

<br>

## 2025.01.15 (수)

### ✅ 오늘 한 일

-   기획 디벨롭
-   와이어프레임 수정
-   디렉토리 구조 수정

### ❣️ 오늘 배운 점

-   서로 논의한 내용을 다시 한 번 확인하는 과정에서, 서로 이해한 내용이 동일한지 확인하는 것이 얼마나 중요한지 배움

<br>

## 2025.01.14 (화)

### ✅ 오늘 한 일

-   레이아웃 완성
-   프로젝트 구조 설계
-   컨설턴트님 회의(16시)

### ❣️ 오늘 배운 점

-   컨설턴트님과의 회의를 통해 이번 프로젝트에서 실질적인 성과를 얻기 위해서는 기획 단계를 더욱 탄탄히 구성해야 한다는 점을 깨달음. 특히, 사용자 입장에서 어떤 요소가 매력적으로 다가올지에 대해 더 깊이 고민할 필요성을 느낌.

-   관통 프로젝트에서는 구조 설계 없이 바로 작업을 진행했지만, 이번에는 구조 설계를 충분히 한 후 수행하게 되어, 이러한 준비 과정이 결과물에 얼마나 긍정적인 영향을 미칠지 기대하고 있음.

<br>

## 2025.01.13 (월)

### ✅ 오늘 한 일

-   기획
-   와이어 프레임 설계

### ❣️ 오늘 배운 점

-   와이어프레임을 설계하는 과정에서 실제 사용자 플로우를 구체적으로 그려보며, 미처 생각하지 못했던 플로우나 기능들을 발견할 수 있었음. 이를 통해 와이어프레임 설계가 단순히 화면 구성을 넘어, 프로젝트의 핵심적인 사용 흐름과 필요한 기능들을 명확히 하는 데 중요한 과정임을 배움.

<br>
