# 📝TIL(Today I Learned)

---

## 2025.01.31 (금)

### ✅ 오늘 한 일

-   [FEAT] 언박싱 스케줄 조회 및 불가능한 시간 막기
-   [FIX] SelectGiftTypeView - 디자인 수정
-   [FIX] SentGiftView 디자인 수정
-   [CHORE] 디테일 수정

### ❣️ 오늘 배운 점

### | useCallback

<details>
<summary> 🤩 자세히 보기 !</summary>

### **`useCallback`의 사용 이유**

-   `useCallback`은 React의 훅(Hook) 중 하나로, **컴포넌트가 리렌더링될 때 동일한 콜백 함수를 재사용**하기 위해 사용
-   즉, **불필요한 함수 재생성을 방지하여 성능 최적화**를 수행

#### ✅ **주요 사용 목적**

1. **불필요한 렌더링 방지**
    - 함수가 불필요하게 다시 생성되는 것을 막아, 하위 컴포넌트가 불필요하게 렌더링되는 것을 방지
2. **메모이제이션을 통한 성능 최적화**
    - `useCallback`을 사용하면 함수가 캐싱되어, **의존성이 변경되지 않으면 같은 함수 객체를 재사용**
3. **함수의 참조값 유지**
    - `useEffect`의 **의존성 배열**에서 함수가 계속 변경되지 않도록 유지할 수 있음
    - `React.memo`와 함께 사용하면 **불필요한 자식 컴포넌트의 리렌더링을 방지**할 수 있음

---

### **📌 `useCallback` 사용 예제**

```jsx
import { useState, useCallback } from "react";
import ChildComponent from "./ChildComponent";

const ParentComponent = () => {
    const [count, setCount] = useState(0);

    // ✅ useCallback을 사용하여 동일한 함수 참조 유지
    const handleClick = useCallback(() => {
        console.log("Button clicked");
    }, []);

    return (
        <div>
            <h1>Count: {count}</h1>
            <button onClick={() => setCount(count + 1)}>Increase Count</button>
            <ChildComponent onClick={handleClick} />
        </div>
    );
};

export default ParentComponent;
```

```jsx
import React from "react";

const ChildComponent = React.memo(({ onClick }) => {
    console.log("ChildComponent re-rendered");
    return <button onClick={onClick}>Click me</button>;
});

export default ChildComponent;
```

#### 📌 **결과**

-   `useCallback`을 사용하지 않으면 `handleClick` 함수가 매번 새로 생성되며 `ChildComponent`가 리렌더링됨.
-   `useCallback`을 사용하면 `handleClick`이 동일한 함수 참조를 유지하여, `ChildComponent`는 `React.memo`로 인해 리렌더링되지 않음.

---

### **`useCallback`의 장단점**

#### ✅ **장점**

1. **불필요한 함수 재생성 방지**
    - 매 렌더링마다 새로운 함수 객체가 생성되는 것을 막음.
2. **자식 컴포넌트의 불필요한 리렌더링 방지**
    - `React.memo`와 함께 사용하면, props로 전달된 함수가 변하지 않아 불필요한 렌더링을 줄일 수 있음.
3. **의존성 배열을 이용한 최적화 가능**
    - 특정 상태나 props가 변경될 때만 함수가 새로 생성되도록 조절 가능.

#### ❌ **단점**

1. **불필요한 `useCallback` 사용 시 오히려 성능 저하**
    - `useCallback` 자체도 메모이제이션 비용이 발생하기 때문에, **함수를 다시 생성하는 비용보다 메모이제이션 비용이 클 경우 성능이 저하될 수 있음**.
    - 예를 들어, 한 번만 사용하는 함수라면 굳이 `useCallback`을 사용할 필요 없음.
2. **의존성 배열 관리 필요**
    - `useCallback` 내부에서 사용하는 변수를 의존성 배열에 포함해야 하므로, 관리가 어려울 수 있음.
    - 잘못된 의존성 설정은 **원하지 않는 동작**을 유발할 수 있음.

---

### **`useCallback` 사용이 적절한 경우**

-   **자식 컴포넌트가 `React.memo`를 사용하고, props로 함수를 전달할 때**
-   **렌더링 최적화가 필요한 경우 (ex. 이벤트 핸들러, API 호출 핸들러)**
-   **의존성이 자주 변경되지 않는 경우**

---

### **`useCallback`을 사용하지 않아도 되는 경우**

-   **간단한 함수** (ex. 단순한 이벤트 핸들러)
-   **컴포넌트가 자주 리렌더링되지 않는 경우**
-   **콜백을 props로 전달할 필요가 없는 경우**

---

### **결론**

-   `useCallback`은 불필요한 함수 재생성을 방지하여 성능을 최적화하는 훅이지만, **무조건 사용하는 것이 최적은 아님**.
-   **자식 컴포넌트의 불필요한 리렌더링을 막을 때 효과적**.
-   **메모이제이션 비용이 함수 재생성 비용보다 높다면 오히려 비효율적**이므로, **적절한 사용이 중요**함.

</details>

<br>

## 2025.01.26 (일)

### ✅ 오늘 한 일

-   [FEAT] LetterView - 403에러 화면 분리
-   [FEAT] ReceiveView - API 호출
-   [FEAT] WriteQuestionLetterView - ShuffleButton 작성
-   [FEAT] SetTimeView - TimeButton 작성

### ❣️ 오늘 배운 점

### | Context API와 Recoil의 차이점

<details>
<summary> 🤩 자세히 보기 !</summary>

| 구분                     | Context API                                           | Recoil                                           |
| ------------------------ | ----------------------------------------------------- | ------------------------------------------------ |
| **사용 목적**            | 글로벌 상태 관리 (주로 테마, 인증, 언어 설정 등)      | 상태 관리 라이브러리 (Redux와 유사한 역할 수행)  |
| **사용 방식**            | `React.createContext()`와 `useContext()` 사용         | `atom`, `selector`, `useRecoilState()` 등 사용   |
| **리렌더링 최적화**      | 부모-자식 관계에서 불필요한 리렌더링이 발생할 수 있음 | Recoil의 `atom` 단위 상태 관리로 리렌더링 최소화 |
| **비동기 지원**          | 자체적으로 지원하지 않음 (useEffect로 처리해야 함)    | `selector`에서 비동기 상태를 쉽게 관리 가능      |
| **Redux 대체 가능 여부** | 대체보다는 보완적인 역할                              | Redux 대체 가능 (Redux보다 사용법이 간단함)      |
| **공식 지원**            | React 기본 제공                                       | Facebook 개발, 별도 라이브러리 설치 필요         |

---

### 1. **Context API 예제**

#### 🔹 `ThemeContext` 정의

```jsx
import React, { createContext, useContext, useState } from "react";

// Context 생성
const ThemeContext = createContext();

export const ThemeProvider = ({ children }) => {
    const [theme, setTheme] = useState("light");

    const toggleTheme = () => {
        setTheme((prev) => (prev === "light" ? "dark" : "light"));
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            {children}
        </ThemeContext.Provider>
    );
};

// useTheme 커스텀 훅 생성
export const useTheme = () => useContext(ThemeContext);
```

#### 🔹 `App.js`

```jsx
import React from "react";
import { ThemeProvider, useTheme } from "./ThemeContext";

const ThemeButton = () => {
    const { theme, toggleTheme } = useTheme();
    return (
        <button
            onClick={toggleTheme}
            style={{
                background: theme === "light" ? "#fff" : "#333",
                color: theme === "light" ? "#000" : "#fff",
            }}
        >
            현재 테마: {theme} (클릭해서 변경)
        </button>
    );
};

const App = () => {
    return (
        <ThemeProvider>
            <div>
                <h1>Context API 사용 예제</h1>
                <ThemeButton />
            </div>
        </ThemeProvider>
    );
};

export default App;
```

🔹 **문제점**

-   `ThemeContext.Provider` 내부의 모든 하위 컴포넌트가 리렌더링됨.
-   규모가 커지면 성능 문제가 발생할 수 있음.

---

### 2. **Recoil 예제**

Recoil을 사용하면 **컴포넌트 간 상태 공유가 더 쉽고, 불필요한 리렌더링이 적습니다.**

#### 🔹 Recoil 상태 정의 (`themeAtom.js`)

```jsx
import { atom } from "recoil";

export const themeState = atom({
    key: "themeState",
    default: "light",
});
```

#### 🔹 `App.js`

```jsx
import React from "react";
import { RecoilRoot, useRecoilState } from "recoil";
import { themeState } from "./themeAtom";

const ThemeButton = () => {
    const [theme, setTheme] = useRecoilState(themeState);

    const toggleTheme = () => {
        setTheme((prev) => (prev === "light" ? "dark" : "light"));
    };

    return (
        <button
            onClick={toggleTheme}
            style={{
                background: theme === "light" ? "#fff" : "#333",
                color: theme === "light" ? "#000" : "#fff",
            }}
        >
            현재 테마: {theme} (클릭해서 변경)
        </button>
    );
};

const App = () => {
    return (
        <RecoilRoot>
            <div>
                <h1>Recoil 사용 예제</h1>
                <ThemeButton />
            </div>
        </RecoilRoot>
    );
};

export default App;
```

🔹 **Recoil의 장점**

-   `atom`을 사용하면 **필요한 컴포넌트만 리렌더링**됨.
-   `selector`를 활용하면 **비동기 상태도 쉽게 관리**할 수 있음.

---

### **정리**

| 비교 항목                | Context API                                   | Recoil                                 |
| ------------------------ | --------------------------------------------- | -------------------------------------- |
| **리렌더링 문제**        | 전역 상태 변경 시 모든 하위 컴포넌트 리렌더링 | `atom`을 사용해 필요한 부분만 리렌더링 |
| **비동기 데이터**        | `useEffect`와 상태 변수를 조합해야 함         | `selector`를 사용해 비동기 관리 가능   |
| **사용 방법**            | `createContext()` + `useContext()`            | `atom`, `selector`, `useRecoilState()` |
| **Redux 대체 가능 여부** | 불가능 (보완적 역할)                          | 가능 (Redux보다 가벼움)                |

-   작은 프로젝트에서는 **Context API**가 적합.
-   **Redux 대체 수준의 상태 관리**가 필요하면 **Recoil**이 적합.

</details>

<br>

## 2025.01.23 (목)

### ✅ 오늘 한 일

-   [FEAT] WriteQuestionLetterView - 초안 개발
-   [FEAT] SetTimeView - MessageSentSuccessfullyModal 작성
-   [FEAT] ReceiveView - 화상 연결 일정 정보 불러오기

### ❣️ 오늘 배운 점

### | hook 과 utils

<details>
<summary> 🤩 자세히 보기 !</summary>

### **`hook` 파일**

-   `hook` 파일은 주로 React와 같은 프레임워크에서 사용되는 커스텀 훅(Custom Hook)을 정의하는 데 사용
-   커스텀 훅은 반복되는 로직을 추출하여 재사용성을 높이고 컴포넌트를 간결하게 유지하기 위한 도구

#### 주요 특징

-   **React 환경**에서 상태 관리, API 호출, 이벤트 처리 등의 로직을 캡슐화.
-   **React 생명주기**와 관련된 로직 포함 가능 (예: `useEffect`, `useState` 활용).
-   컴포넌트의 상태와 동작을 관리하는 데 초점.

#### 예시

```javascript
// hooks/useFetchData.js
import { useState, useEffect } from "react";

export const useFetchData = (url) => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        fetch(url)
            .then((res) => res.json())
            .then((data) => {
                setData(data);
                setLoading(false);
            });
    }, [url]);

    return { data, loading };
};
```

**사용**

```javascript
import { useFetchData } from "./hooks/useFetchData";

const MyComponent = () => {
    const { data, loading } = useFetchData("/api/data");

    return loading ? <p>Loading...</p> : <div>{JSON.stringify(data)}</div>;
};
```

#### 목적

-   React 컴포넌트의 로직을 모듈화하여 재사용성을 높임.
-   상태 및 생명주기 로직을 분리해 컴포넌트의 가독성 향상.

---

### **`utils` 파일**

-   `utils` 파일은 **일반적으로 사용되는 순수 함수**나 **독립적인 유틸리티 함수**를 정의하는 데 사용
-   React와 무관하게 동작하며, 특정 데이터 처리, 형식 변환, 계산 등을 담당

#### 주요 특징

-   **프레임워크 비의존적**: React, Vue, Node.js 등 어디에서든 사용 가능.
-   상태 관리나 생명주기 로직이 필요하지 않은 순수한 작업 포함.
-   **범용적인 재사용**이 가능한 함수 모음.

#### 예시

```javascript
// utils/calculate.js
export const calculateSum = (numbers) =>
    numbers.reduce((sum, num) => sum + num, 0);
```

**사용**

```javascript
import { calculateSum } from "./utils/calculate";

const MyComponent = () => {
    const numbers = [1, 2, 3, 4];
    const sum = calculateSum(numbers);

    return <p>Sum: {sum}</p>;
};
```

#### 목적

-   데이터 처리, 형식 변환 등 반복되는 로직을 추출해 코드 중복을 방지.
-   비즈니스 로직과 관련된 핵심 기능 제공.

---

### **차이점 요약**

| **구분**      | **`hook` 파일**                                            | **`utils` 파일**                                         |
| ------------- | ---------------------------------------------------------- | -------------------------------------------------------- |
| **주요 역할** | React 컴포넌트와 관련된 상태 및 로직 처리                  | 데이터 처리, 계산 등 순수 함수 제공                      |
| **사용 환경** | React 환경 (주로 함수형 컴포넌트)                          | 프레임워크와 무관 (React, Node.js 등 어디서든 사용 가능) |
| **포함 내용** | 상태 관리, 생명주기 로직, 이벤트 핸들링 등 React 전용 로직 | 데이터 변환, 계산, 유틸리티 함수 등                      |
| **의존성**    | React 훅(`useState`, `useEffect` 등) 의존                  | 의존성 없음 (순수 함수)                                  |
| **예시**      | API 호출, 컴포넌트 상태 관리                               | 숫자 합계 계산, 날짜 포맷 변환                           |

---

### 결론

-   **React 컴포넌트 로직**을 모듈화하려면 `hook` 파일.
-   **독립적인 유틸리티 함수**를 재사용하려면 `utils` 파일.

</details>

<br>

## 2025.01.22 (수)

### ✅ 오늘 한 일

-   SelectLetterTypeView/SelectGiftTypeView/SentGiftView/WriteGeneralLetterView 뼈대 작성
-   API 관련 해서 react 코드 확인

### ❣️ 오늘 배운 점

-   관통 프로젝트에서 router를 이용한 api 호출이 react에서는 어떠한 흐름으로 변하게 되었는지 배움.

<br>

### React에서 API를 활용하기

---

<details>
<summary> 1. 폴더 구조</summary>

```
src/
├── components/       # UI 컴포넌트 폴더
│   ├── UserList.jsx
├── services/         # API 호출 관련 파일
│   ├── api.js
├── hooks/            # 커스텀 훅
│   ├── useFetchUsers.js
├── App.js            # 메인 컴포넌트
├── index.js          # 진입 파일
```

---

</details>

<details>
<summary> 2. 코드 예시 </summary>

#### **1. API 호출 함수 (services/api.js)**

```javascript
import axios from "axios";

// Axios 기본 설정
const api = axios.create({
    baseURL: "https://jsonplaceholder.typicode.com", // API의 기본 URL
    headers: {
        "Content-Type": "application/json",
    },
});

// 사용자 데이터 가져오기
export const fetchUsers = async () => {
    const response = await api.get("/users");
    return response.data;
};
```

#### **2. 커스텀 훅 (hooks/useFetchUsers.js)**

```javascript
import { useState, useEffect } from "react";
import { fetchUsers } from "../services/api";

const useFetchUsers = () => {
    const [users, setUsers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const getUsers = async () => {
            try {
                const data = await fetchUsers();
                setUsers(data);
            } catch (err) {
                setError(err.message);
            } finally {
                setLoading(false);
            }
        };

        getUsers();
    }, []);

    return { users, loading, error };
};

export default useFetchUsers;
```

#### **3. 사용자 목록 컴포넌트 (components/UserList.jsx)**

```javascript
import React from "react";
import useFetchUsers from "../hooks/useFetchUsers";

const UserList = () => {
    const { users, loading, error } = useFetchUsers();

    if (loading) return <p>Loading...</p>;
    if (error) return <p>Error: {error}</p>;

    return (
        <ul>
            {users.map((user) => (
                <li key={user.id}>
                    {user.name} ({user.email})
                </li>
            ))}
        </ul>
    );
};

export default UserList;
```

#### **4. 메인 컴포넌트 (App.js)**

```javascript
import React from "react";
import UserList from "./components/UserList";

const App = () => {
    return (
        <div>
            <h1>User List</h1>
            <UserList />
        </div>
    );
};

export default App;
```

</details>

<br>

## 2025.01.21 (화)

### ✅ 오늘 한 일

-   next에서 react로 전환하여 ReceiveView & LetterView 수정(API는 추가로 수정해야함)
-   API 관련 해서 react 코드 확인

### ❣️ 오늘 배운 점

-   React에서 API를 호출하는 방식에 대해 조금 알게되었음.
-   관통 프로젝트 때와 달리, 한 페이지에 모든 컴포넌트를 넣는 방식이 아닌 공통적으로 계속 활용되는 컴포넌트는 common 폴더에서 관리하고 활용하는 방식으로 진행하는 방법을 배움.
-   컨설턴트님의 피드백 덕분에 export default와 export의 차이를 알게 되었음. 이전처럼 막 코드를 작성하는 것이 아니라, 최대한 깔끔하고 구조화된 코드를 작성하려고 노력해야겠다고 생각함.
    (물론, 마감 기한을 준수하는 것이 가장 중요!)

<br>

### | export default vs export

| **특징**          | **`export default`**                           | **`export`**                                   |
| ----------------- | ---------------------------------------------- | ---------------------------------------------- |
| **내보내기 개수** | 한 모듈에 하나만 사용 가능                     | 여러 값을 내보낼 수 있음                       |
| **가져오기 이름** | 이름을 자유롭게 지정 가능                      | 정확한 이름으로 가져와야 함                    |
| **사용 사례**     | 주요 값(기능, 클래스 등) 하나만 내보낼 때 적합 | 여러 값(유틸리티 함수, 상수 등) 내보낼 때 적합 |

---

<br>

## 2025.01.20 (월)

### ✅ 오늘 한 일

-   next에서 파라미터 전달하는 방법 이해
-   next에서 react로 전환(SSR을 사용하지 않기로 함)

### ❣️ 오늘 배운 점

-   아무 생각 없이 Next.js를 사용하기로 했지만, 오늘 우리가 정말 Next.js를 사용할 이유가 있는지 다시 고민해볼 기회를 가질 수 있어 좋았음. 특히 렌더링 방식에 대해 깊이 알지 못했는데, 이번 기회를 통해 SSR, CSR, SSG의 특징과 차이점을 배울 수 있었음.

<br>

### | React 대비 Next.js의 차이

| **기능**          | **React**                    | **Next.js**                  |
| ----------------- | ---------------------------- | ---------------------------- |
| **렌더링 방식**   | CSR(CSR 확장 가능)           | CSR, SSR, SSG, ISR 모두 지원 |
| **라우팅**        | 수동 설정(React Router 필요) | 파일 기반 라우팅             |
| **SEO**           | 기본적으로 SEO 비적합        | SSR/SSG로 SEO 최적화 가능    |
| **이미지 최적화** | 수동 처리 필요               | Next.js Image 컴포넌트 제공  |
| **백엔드 통합**   | 별도 설정 필요               | API Routes 기본 제공         |

---

<br>

### | 렌더링 방식의 차이

| 렌더링 방식 | **데이터 가져오는 위치**     | **HTML 생성 시점**          | **SEO** | **사용 사례**                   |
| ----------- | ---------------------------- | --------------------------- | ------- | ------------------------------- |
| **CSR**     | 클라이언트                   | 브라우저에서 동적으로 생성  | 불리함  | 대화형 SPA, 실시간 대시보드     |
| **SSR**     | 서버                         | 요청 시마다 생성            | 유리함  | 블로그, 전자상거래 사이트       |
| **SSG**     | 빌드 시(Build Time)          | 빌드 시 미리 생성           | 유리함  | 정적 콘텐츠 제공 웹사이트       |
| **ISR**     | 빌드 시 + 일정 주기마다 갱신 | 빌드 시 생성 후 주기적 갱신 | 유리함  | 콘텐츠가 자주 변경되는 웹사이트 |

---

<br>

## 2025.01.17 (금)

### ✅ 오늘 한 일

-   프로젝트 생성

### ❣️ 오늘 배운 점

-   프로젝트를 생성하며 버전과 기본 설정을 다시 한번 신중히 검토하는 기회를 가질 수 있었음음. 예를 들어, Next.js에서 앱 라우터(App Router)와 페이지 라우터(Page Router) 중 어떤 방식을 사용할지 고민했고, 각 방식에 따른 디렉토리 구조와 명명의 차이점을 고려하며 적합한 선택을 내리고자 함.

<br>

#### | 페이지 라우터 vs 앱 라우터 구조 비교

| **기능**               | **페이지 라우터**                            | **앱 라우터**                                   |
| ---------------------- | -------------------------------------------- | ----------------------------------------------- |
| **라우트 정의 방식**   | 파일 이름 기반 (`pages/index.js` → `/`)      | 디렉토리와 파일 역할 기반 (`app/page.js` → `/`) |
| **공통 레이아웃 관리** | `_app.js`로 전체 페이지 공통 레이아웃 관리   | `layout.js`로 경로별 공통 레이아웃 관리         |
| **동적 라우팅**        | `[id].js` 파일로 구현                        | `[id]/page.js` 디렉토리로 구현                  |
| **API 라우트 위치**    | `pages/api/` 디렉토리 (`pages/api/posts.js`) | `app/api/` 디렉토리 (`app/api/posts/route.js`)  |
| **중첩 라우팅**        | 지원하지 않음                                | `layout.js`를 사용해 중첩 라우팅 지원           |

<br>
 
### | Next.js 13 vs Next.js 14 비교

| **특징**                          | **Next.js 13**                   | **Next.js 14**                          |
| --------------------------------- | -------------------------------- | --------------------------------------- |
| **App Router**                    | 초기 도입, 사용 가능             | 기능 개선 및 안정화                     |
| **React Server Components (RSC)** | 기본 지원                        | RSC 최적화 및 사용성 개선               |
| **번들러**                        | Webpack (TurboPack은 실험적)     | TurboPack 기본 지원                     |
| **Server Actions**                | 지원되지 않음                    | 서버에서 동작하는 함수 도입             |
| **SEO 및 메타 관리**              | 기본적인 메타 관리               | Metadata API로 더 세밀한 메타 관리 가능 |
| **Open Graph 이미지**             | 정적 이미지 사용                 | 동적 Open Graph 이미지 생성 지원        |
| **빌드 속도**                     | Webpack 기반으로 상대적으로 느림 | TurboPack으로 더 빠른 빌드              |
| **ESM 지원**                      | 실험적 ESM 지원                  | ESM이 기본 설정                         |
| **CSS/JS 최적화**                 | 기본 제공                        | 더 세밀하고 빠른 최적화                 |

<br>

## 2025.01.16 (목)

### ✅ 오늘 한 일

-   프론트엔드 디렉토리 구조 확정
-   Jira 백로그 작성

### ❣️ 오늘 배운 점

-   우리 팀이 JIRA 이슈 관리에서 1위를 기록한 점이 재밌었음. 생성된 이슈들을 체계적으로 해결해 나간다면 프로젝트를 성공적으로 마무리할 수 있을 것이라는 확신이 듦. JIRA를 활용할 기회가 흔치 않은 만큼, 이번 기회를 통해 효과적으로 사용법을 익히고 협업 능력을 더욱 강화할 수 있기를 기대함.

<br>

## 2025.01.15 (수)

### ✅ 오늘 한 일

-   기획 디벨롭
-   와이어프레임 수정
-   디렉토리 구조 수정

### ❣️ 오늘 배운 점

-   서로 논의한 내용을 다시 한 번 확인하는 과정에서, 서로 이해한 내용이 동일한지 확인하는 것이 얼마나 중요한지 배움

<br>

## 2025.01.14 (화)

### ✅ 오늘 한 일

-   레이아웃 완성
-   프로젝트 구조 설계
-   컨설턴트님 회의(16시)

### ❣️ 오늘 배운 점

-   컨설턴트님과의 회의를 통해 이번 프로젝트에서 실질적인 성과를 얻기 위해서는 기획 단계를 더욱 탄탄히 구성해야 한다는 점을 깨달음. 특히, 사용자 입장에서 어떤 요소가 매력적으로 다가올지에 대해 더 깊이 고민할 필요성을 느낌.

-   관통 프로젝트에서는 구조 설계 없이 바로 작업을 진행했지만, 이번에는 구조 설계를 충분히 한 후 수행하게 되어, 이러한 준비 과정이 결과물에 얼마나 긍정적인 영향을 미칠지 기대하고 있음.

<br>

## 2025.01.13 (월)

### ✅ 오늘 한 일

-   기획
-   와이어 프레임 설계

### ❣️ 오늘 배운 점

-   와이어프레임을 설계하는 과정에서 실제 사용자 플로우를 구체적으로 그려보며, 미처 생각하지 못했던 플로우나 기능들을 발견할 수 있었음. 이를 통해 와이어프레임 설계가 단순히 화면 구성을 넘어, 프로젝트의 핵심적인 사용 흐름과 필요한 기능들을 명확히 하는 데 중요한 과정임을 배움.

<br>
